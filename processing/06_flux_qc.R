### ============================================================================
# Flux quality control =========================================================
### ============================================================================

# Purpose: 

# References:

# Vitale, D., Fratini, G., Bilancia, M., Nicolini, G., Sabbatini, S., & Papale, 
# D. (2020). A robust data cleaning procedure for eddy covariance flux 
# measurements. Biogeosciences, 17(6), 1367â€“1391. 
# https://doi.org/10.5194/bg-17-1367-2020


# Input(s):

# Output(s):

start_time <- Sys.time()

# Load the required packages
library(lubridate, warn.conflicts = FALSE)
library(tidyverse)

# Load reference files
source("/Users/Graham/Desktop/DATA/Flux/tools/reference/site_metadata.R")
source("/Users/Graham/Desktop/DATA/Flux/tools/reference/essential_vars.R")

# Load RFlux functions
# TODO these need to be re-written and included in this script
devtools::load_all("/Users/Graham/Desktop/DATA/Flux/tools/RFlux", quiet = TRUE)

# Load functions
path_funs <- "/Users/Graham/Desktop/DATA/Flux/tools/engine/functions"
source(file.path(path_funs, "clean.R"))
source(file.path(path_funs, "dates_and_times.R"))
source(file.path(path_funs, "flag.R"))
source(file.path(path_funs, "latest_version.R"))
source(file.path(path_funs, "utilities.R"))


### Helper functions ===========================================================



### Initialize script settings & documentation =================================

# Load metadata file
md <- purrr::pluck(site_metadata, settings$site)

# Set the desired working directory in RStudio interface
# - assumes that the subdirectory structure is already present
wd <- file.path(
  "/Users/Graham/Desktop", "DATA", "Flux", settings$site, settings$year
)
path_in <- file.path(wd, "processing", "04_biomet_gapfill", "data")
ep_path_in <- file.path(wd, "processing", "01_combine_eddypro")
fp_path_in <- file.path(wd, "processing", "05_footprint", "stats")

# Input file - biomet output with QC flags
data_input <- latest_version(path_in, "biomet_gf")

# EddyPro outputs (for RFlux)
ep_path <- latest_version(file.path(ep_path_in, "full_output"))
qc_path <- latest_version(file.path(ep_path_in, "qc_details"))
md_path <- latest_version(file.path(ep_path_in, "metadata"))

# Stats generated by RFlux
st_path <- latest_version(file.path(wd, "processing", "00_raw_output", "stats"))

# Footprint inputs
fp_inputs <- latest_version(
  fp_path_in, paste0("footprint_stats_", c("K15", "KM01"))
)
#fetch_input <- latest_version(fp_path_in, "fetch")

# Set tag for creating output file names
tag_out <- create_tag(settings$site, settings$year, settings$date)

# Set path for output files
path_out <- file.path(wd, "processing", "06_flux_qc")


### Load required input data ===================================================

cat("Importing data.\n")

# Load the data
data <- readr::read_csv(
  data_input, guess_max = 6000, 
  col_types = readr::cols(.default = readr::col_guess()), progress = FALSE
)

# Load the footprint data
fp <- fp_inputs %>%
  purrr::map(~ readr::read_csv(
    .x, guess_max = 6000, 
    col_types = readr::cols(.default = readr::col_guess()), progress = FALSE
  )) %>%
  purrr::reduce(dplyr::full_join, by = "timestamp")

# Bind footprint data to main data frame
data <- dplyr::left_join(data, fp, by = "timestamp")


### Error levels ===============================================================

# Create workset for RFlux input
# - this just gathers data so doesn't need to be written to file
workset <- ecworkset(ep_path, qc_path, md_path, st_path)

# Pre-screen fluxes for periods when rain may have affected sensors
# - A big question is whether to do this before or after running cleanFlux
# - I think before since cleanFlux looks for statistical evidence of problems
# - Makes sense to omit points with known errors from consideration altogether
workset <- workset %>%
  # Add gap-filled rain data
  dplyr::bind_cols(dplyr::select(data, p_rain_f)) %>%
  dplyr::mutate(dplyr::across(
    c(H, LE, co2_flux, ch4_flux, co2_strg, ch4_strg),
    ~ dplyr::if_else(!is.na(p_rain_f) & p_rain_f != 0, NA_real_, .x)
  )) %>%
  dplyr::select(-p_rain_f)

# Run the quality control procedure, write to file
cleanFlux(
  workset, md_path, 
  path_output = file.path(path_out, "results"), 
  file_name = paste0("qc_results_", tag_out), 
  plot_qc = FALSE, storage = TRUE
) 

# Read in results
data_c <- readr::read_csv(
  latest_version(file.path(path_out, "results")),  
  col_types = readr::cols(.default = readr::col_guess()), 
  na = c("", "NA", "-9999"), guess_max = 6000, progress = FALSE
)

# Parse timestamp and tidy
data_c <- data_c %>%
  dplyr::rename_with(tolower) %>%
  dplyr::mutate(timestamp = lubridate::ymd_hm(timestamp_end), .before = 1) %>%
  dplyr::select(-h, -le, -fc, -nee, -fm, -fch4) %>%
  # Storage-corrected fluxes are indicated by 'uncleaned' suffix
  dplyr::rename_with(~ stringr::str_remove(.x, "_uncleaned")) %>%
  # 'nee' is replaced with 'fc' for continuity
  dplyr::rename_with(~ stringr::str_replace(.x, "nee", "fc")) %>%
  # Data flags are renamed with 'qc' prefix for continuity
  dplyr::rename_with(
    ~ stringr::str_c("qc_", stringr::str_remove(.x, "_flag")), 
    dplyr::ends_with("data_flag")
  ) %>%
  dplyr::left_join(dplyr::select(data, timestamp, night), by = "timestamp")

# Recode outlying flags
# 0 = not an outlier
# 1 = outlier without data problem/error
# 2 = outlier with potential underlying data problem/error
data_c <- data_c %>%
  dplyr::mutate(
    qc_h_outlier = dplyr::if_else(
      h_outlying_flag == 1 & qc_h_data > 0, 2, h_outlying_flag
    ),
    qc_le_outlier = dplyr::if_else(
      le_outlying_flag == 1 & qc_le_data > 0, 2, le_outlying_flag
    ),
    qc_fc_outlier = dplyr::if_else(
      fc_outlying_flag == 1 & qc_fc_data > 0, 2, fc_outlying_flag
    ),
    qc_fch4_outlier = dplyr::if_else(
      fch4_outlying_flag == 1 & qc_fch4_data > 0, 2, fch4_outlying_flag
    )
  ) %>%
  # Drop original flags
  dplyr::select(-dplyr::ends_with("outlying_flag"))

data_c <- dplyr::mutate(
  data_c,
  qc_h = combine_flags(qc_h_data, qc_h_outlier),
  qc_le = combine_flags(qc_le_data, qc_le_outlier),
  qc_fc = combine_flags(qc_fc_data, qc_fc_outlier),
  qc_fch4 = combine_flags(qc_fch4_data, qc_fch4_outlier),
  .before = "h_resid"
)

# Examine flags
data_c %>%
  mutate(qc = factor(qc_fc_data)) %>%
  ggplot(aes(timestamp, fc, color = qc)) +
  facet_wrap(~ night) +
  geom_point() +
  ylim(-40, 40)
data_c %>%
  mutate(qc = factor(qc_fch4_data)) %>%
  ggplot(aes(timestamp, fch4, color = qc)) +
  facet_wrap(~ night) +
  geom_point() +
  ylim(-0.75, 1.25)

# Outlier detection
# - seasonal-trend decomposition based on LOESS

# Examine flags
data_c %>%
  mutate(
    qc = factor(qc_fc_outlier),
    fc = if_else(qc_fc_data == 2, NA_real_, fc)
  ) %>%
  ggplot(aes(timestamp, fc, color = qc)) +
  facet_wrap(~ night) +
  geom_point()
data_c %>%
  mutate(
    qc = factor(qc_fch4_outlier),
    fch4 = if_else(qc_fch4_data == 2, NA_real_, fch4)
  ) %>%
  ggplot(aes(timestamp, fch4, color = qc)) +
  facet_wrap(~ night) +
  geom_point()

# Examine data without outliers
data_c %>%
  mutate(fc = clean(fc, qc_fc)) %>%
  ggplot(aes(timestamp, fc)) +
  geom_point()
data_c %>%
  mutate(fch4 = clean(fch4, qc_fch4)) %>%
  ggplot(aes(timestamp, fch4)) +
  geom_point()

# Other things to possibly look at:
# - excessive spectral correction factor (>3)
# - gas mixing ratio
# - sensor stability
#   - ch4 fluxes with RSSI < 10 are already removed by EddyPro
# - residual vertical wind component (>0.35)
# - t_sonic_sigma (>1) - for fc


# Flag high uncertainty (i.e. low quality) in remaining fluxes
# remove ch4 random uncertainty > 0.2? (see Runkle2019)
data_c %>% 
  mutate(
    fc = clean(fc, qc_fc),
    qc = factor(pull(data, fc_randunc_hf) > 5)
  ) %>%
  ggplot(aes(timestamp, fc, color = qc)) +
  geom_point()
data_c %>% 
  mutate(
    fch4 = clean(fch4, qc_fch4),
    qc = factor(pull(data, fch4_randunc_hf) > 0.1)
  ) %>%
  ggplot(aes(timestamp, fch4, color = qc)) +
  geom_point()
data_c <- data_c %>%
  dplyr::mutate(
    fc_rand_unc = dplyr::pull(data, fc_randunc_hf),
    fch4_rand_unc = dplyr::pull(data, fch4_randunc_hf),
    
    fc_unc_flag = flag_thr(fc_rand_unc, 5, "higher"),
    fch4_unc_flag = flag_thr(fch4_rand_unc, 0.1, "higher")
  )

# Footprint coverage of AOI
data_c %>%
  mutate(fc = clean(fc, qc_fc)) %>%
  left_join(fp) %>%
  ggplot(aes(timestamp, fc, color = phi_k15 > 0.80)) +
  geom_point(size = 1)
# Phi K15 looks GOOD
data_c %>%
  mutate(fc = clean(fc, qc_fc)) %>%
  left_join(fp) %>%
  ggplot(aes(timestamp, fc, color = phi_km01 > 0.80)) +
  geom_point(size = 1)
data_c %>%
  mutate(fch4 = clean(fch4, qc_fch4)) %>%
  left_join(fp) %>%
  ggplot(aes(timestamp, fch4, color = phi_k15 > 0.80)) +
  geom_point(size = 1)
data_c %>%
  mutate(fch4 = clean(fch4, qc_fch4)) %>%
  left_join(fp) %>%
  ggplot(aes(timestamp, fch4, color = phi_km01 > 0.80)) +
  geom_point(size = 1)


data_c <- data_c %>%
  dplyr::mutate(
    phi_k15 = dplyr::pull(fp, phi_k15),
    phi_km01 = dplyr::pull(fp, phi_km01),
    
    phi_k15_flag = flag_thr(phi_k15, 0.80, "lower"),
    phi_km01_flag = flag_thr(phi_km01, 0.80, "lower")
  )

# Select necessary information from QC results, bind to main data frame
data_full <- data_c %>%
  dplyr::select(
    timestamp, qc_h, qc_le, qc_fc, qc_fch4, fc_unc_flag, fch4_unc_flag, 
    phi_k15_flag, phi_km01_flag, foot_flag
  ) %>%
  dplyr::left_join(data, ., by = "timestamp")

# Write output to file
data_full_out <- file.path(
  path_out, "data", paste0("flux_qc_full_", tag_out, ".csv")
)
readr::write_csv(data_full, data_full_out)



